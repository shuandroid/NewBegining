# 代码二三事


* 实践规范：
	- 成员变量能不使用就不使用
	- 静态成员变量，放在最前面
	- 对外的接口要尽~可能少
	- 相对布局`percentLayout`要熟练
	- 成员变量和方法名的命名需要格外谨慎，可以恰到好处的解释该成员变量和方法的作用
	- 操作数据库和`sharedPreference`时，需要考虑到上线后的成本，要十分谨慎
	- 要考虑是否造成资源浪费（不只是bitmap等资源，listener也是一种资源）
	- `ConcurrentHashMap` 并发可能的地方，要格外注意
	- 操作`sharedPreference `和`DB`时，要考虑当前工作的进程，是否跨进程存取数据
	- `ContentProvider`和`ContentObserver`是否涉及到跨进程
	- `activity`一般为主进程，`controller`可放在work进程
	- 若为单例，构造函数里面的对象会一直存在，尽可能不要放入一些`view`等的初始化
	- 在写`setText`时要考虑到多语言的问题，不要使用“+”去连接两个string。
	- 操作文件时注意要文件时否操作成功，file.delete;file.mkdirs()等，接收它们的返回值来判断是否成功
	- 写某个类时要考虑到后面人使用的建议程度及暴露在外部的接口尽可能少，参数也尽可能简洁
	- 编写thread时，，，千万注意要开始thread，即`Thread.start()`
	- 涉及到activity对数据进行操作时，要考虑到数据随生命周期的变化，考虑到activity的特殊销毁方式
	- 低版本4.0.3之前， 不支持`layout_margin_bottom`属性


	

**想到优化代码**  

减少内存访问

```
if (map.contains(key)) {
	if (map.get(key)) {
		//处理逻辑
	}
}
```
可替换为：

```
Boolean isTrue = map.get(key);
if (null != isTrue) {
	if(isTrue) {
		//处理逻辑
	}
}
```
因为第一种需要操作两次map，耗费的时间和内存比第二种要多。

```
if(!TextUtils.isEmpty(text))
//等效于
if(null != text && text.equals(""))
```

强条件的判断，可直接return，代码的逻辑更清楚；

```
private void createShortcut() {
	if(bitmap == null) {
		return;
	}
	
	//createShortcut...
	
}
```

**View 的监听事件**

```
view.setOnTouchListener(new View.OnTouchListener() {
	@Override
	public booolean onTouch(View v, MotionEvent event) {
		//一次点击事件可能会被调用多次，因为一次点击事件，可能会包含多次action
		if(event.getAction == MotionEvent.ACTION_UP) {
			//只会处理一次，因为只包含一个ACTION_UP 的action
			...
			...
		}
	}

}); 
```

**imageView 的设置**

```
imageView.setBackgroundResource(...);
imageView.setBackgroundDrawable(...);

//与

imageView.setImageResource(...);
imageView.setImageDrawable(...);

//两者是不同的，一般来说，background更广一些；
//有时可能会出现图片重叠的现象，是因为为一个imageView同时设置了background和image造成的

//设置imageview的scale属性可使image去扩充到background大小
android:scaleType="centerCrop"
```

**view 的setOnClickListener**

```
button.setOnclickListener(...)
//若在此的前面设置setClickable(false);会不起作用，因为在`setOnClickListener()`里面会重新把button设置为clickable 为true。

//要下面的形式去设置；
button.setOnclickListener(...);
button.setClickable(false);
```

**file 的 删除**

```
//对某个文件的删除
boolean isDeleted = file.delete();
//返回值为删除是否成功的标志

//对于文件夹的删除：
file.delete();//只能删除文件和空的文件夹
//当想要删除文件夹是要采用递归删除
private boolean deleteDir(File fileDir) {
	if (fileDir.isFile()) {
            fileDir.delete();
            return;
        }

   if (fileDir.isDirectory()) {
        File files[] = fileDir.listFiles();

        if (null == files && 0 == files.length) {
             fileDir.delete();
             return;
        }

        for (File file : fileDir.listFiles()) {
            deleteDir(file);
        }

        fileDir.delete();
    }
}
```


**文件流等流的操作**

```
        //流的操作一定要注意`close`,否则会造成内存的不必要浪费
        //为了成功关闭文件流，在finally里去关闭流
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(file);
            size = fileInputStream.available();
        } catch (IOException e) {
            e.printStackTrace();

        } finally {
            if (fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
```

**lambda 表达式**

```
handler.postDelayed(new Runnable() {
	@Override
	public void run() {
		finish();
	}
}, 1000);

//可写为：
handler.postDelayed(()->finish(), 1000);

handler.postDelayed(this::finish, 1000);
```

****


**并发涉及到的问题**

* CopyOnWriteList
* 


**布局文件注意事项**

如果一个`view`是在一个`textView`下面,则写xml时，需要针对这个`TextView`设置`layout_marginTop="xdp"`, 而不应该对该view以其他为标准设置位置，因为`TextView`可能会因为文字的多少而改变自身的高度。

**padding 与 margin 对同一个控件的影响**

例如：父控件为LinearLayout, 子控件为button，下面两种设置的方式效果是一样的：

- 当父控件设置了`padding="8dp"`

	padding 是内边框， 使得该父控件里的子view的空间都会减少8dp
- 子控件设置了`layout_margin="8dp"`

	margin 是相对button而言的，使得自身距离父控件各个方向有8dp的距离；
	
> 上面两种，实际button的点击区域，view的绘制区域都是相同的，但是padding后使得linearlayout里content会缩小8dp的距离，而margin则不会影响content的区域大小，从而造成一些特定情况下的问题。在margin下，button可以显示设置的阴影，而padding则没有足够的content去显示阴影。




**实践问题2333**

* 若代码的逻辑不理想时，是不是可以人为添加回调接口，把需要再次运行的逻辑放入顺序逻辑中；

	> 回调有时可大大简化代码逻辑


* 多分析代码，会发现有些`boolean`和`string`或其他了类型的内容有相似或共同部分，可简化代码

* 若对某一个view重写了，若十分独立，是否可以考虑把该view里面的所有子view的初始化、监听、逻辑处理都封装在这个重写的view里面；

* 尽可能不要让代码晦涩，使用越简单的方式去实现可能出现的问题就会越少。使用包装类，内部包装类。

* Handler的效率： 
	- handler.sendMessage() 
	- handler.handleMessage()

	使用这两者去处理一些稍微复杂的问题，效率较高, 如下：
	
	```
	Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            cleanButton.setClickable(false);
            switch (msg.what) {
                case 1:
                    cleanButton.setText(getContext().getResources().getString(R.string.whats_app_button_clean) + "(" + 3 + "s)");
                    break;
                case 2:
                    cleanButton.setText(getContext().getResources().getString(R.string.whats_app_button_clean) + "(" + 2 + "s)");
                    break;
                case 3:
                    cleanButton.setText(getContext().getResources().getString(R.string.whats_app_button_clean) + "(" + 1 + "s)");
                    break;
                case 4:
                    cleanButton.setClickable(true);
                    cleanButton.setBackgroundResource(R.drawable.whats_app_clean_red_button);
                    cleanButton.setText(getContext().getResources().getString(R.string.whats_app_button_clean));
                default:
                    break;
            }
        }
    };

    handler.sendEmptyMessageDelayed(1, 0);
    handler.sendEmptyMessageDelayed(2, 1000);
    handler.sendEmptyMessageDelayed(3, 2000);
    handler.sendEmptyMessageDelayed(4, 3000);
    
    //可优化，只发送一条message， 在case里再发送消息
	```
* 自定义`view`代码中 关于`getWidth()`

	getWidth()， 是得到view 的宽度，需要注意的是，view必须在`onMeasure`后才会具有高度，所有在view的构造函数中，**getWidth()为0！！！**  
	
* AnimatorSet.playTogether()问题

	可能会把`animatorSet`在前面加进去的`animator`同时也跑动起来，造成动画奇怪问题，需要注意。


* 控制成员变量的数量

	在写代码的过程中，有时在一个方法里面会涉及到一个局部变量，而在后续的操作中，可能会继续使用到该变量，会优先考虑把它变成成员变量（全局变量）。但是在后期的检查代码中，应该考虑是否可以通过传参的方法，取消该成员变量，变成一个局部变量。

* 扫雷注意部分：

	1. 在4.4以下，使用`RemoteViews` 实现 `notification` 时，布局文件里如果有`AppCompatImageView` 会导致 crash.
		
		解决方案： 使用 `ImageView` 代替，如果 `ImageView` 里使用的是`SVG`, 则需要将`SVG` 转换为 `Bitmap` 否则也会 crash
	2.  频繁使用同一个 `view` 弹出和隐藏悬浮窗 可能会导致 crash

		所有版本上，WindowManager的removeView(View view)方法可以移除浮动窗，但是这个方法并不是立即执行移除操作，而是post消息执行。因此当下一次展示浮动窗【addView(View view)】迅速执行，在移除操作之前的话，那么上一次的移除会将当前展示的View的mParent对象给置为null。这会导致不可预期的Crash。
		
		解决方法： 
		
		1. view 对象尽量不要重复使用显示悬浮窗
		2. 调用 `removeViewImmediate(View view)` 方法来执行移除,可立即执行


	3. `Canvas` 的 `clipPath` 可能导致 `crash`

		4.3以下， 在启用硬件加速情况下，调用 `canvas` 的 `clipPath()` 会导致 crash，报错：`UnsupportedOperationException`
	
		解决方法：
	
		1. 低于4.3， 将 `view` 的硬件加速关闭, 使用：

			```
			setLayerType(View.LAYER_TYPE_SOFTWARE, null);
			```
		
		2. 如不确定是否关闭了硬件加速，可通过 `Canvas.isHardwareAccelerated()` 进行判断。

	
	4. `ContentProvider` 可能导致内存泄漏

		在 4.0.3/4.0.4 上会导致严重的内存泄漏。其他版本较轻。
	
		在ContentProvider的onCreate()方法中依赖其他ContentProvider，会导致ContentProvider的生命周期被打乱，导致内存泄漏，产生多个ContentProvider实例，并且无法释放。
	
		解决方法： 不在ContentProvider未加载完全情况下（如：onCreate()方法过程中）对其他ContentProvider产生依赖。
	
	5.  `?attr` 描述资源可能导致 crash

		在低版本上，`4.0.3/4.0.4` 上，使用 `?attr/res_name` 方式描述资源类型，在根标签 `shape` 的 `xml` 资源中会出现 crash. 无法找到 res_name 对应的资源。
	
		解决方法：不在 `shape` 中使用 `?attr/res_name`方式描述资源.
	
	6. Animator 使用可能导致 crash

		在低版本 `4.1.1/4.1.2` 上，使用 `animator` 的 `onAnimationRepeat()` 调用 Animator 的 `cancel()` 会导致 crash， 报错：`java.lang.IndexOutOfBoundsException`.
	
		解决方法: 使用 `handler` 将 `cancel()` 抛后执行，：
	
		```
		@Override
   		public void onAnimationRepeat(Animator animation) {
       		new Handler().post(new Runnable() {
            	@Override
            	public void run() {
               	 animator.cancel();
            	}
       		});
  	 	}
		```
	
	7. 使用 `Application` 的 `Context` 使用 `getResource().getDrawable(resId)` 或 `ContextCompat.getDrawable(context, resId)`，，当`resId`是`svg`时在5.0以下会`crash`:

		解决方法：
	
		1. 使用 `AppCompatActivity` 的 `context` 
		2. 如果  `resId` 一定是 `vector` 使用 `VertorDrawableCompat.create()` 方法
	
	8. `fragment` 的 `getActivity` 可能为空， 导致空指针异常，另外使用 `getString` `getResource`方法也可能会导致 crash.

		`fragment` 中执行异步操作，可能在异步操作的回调时， `fragment` 已经和 `Activity` 分开，导致 `getActivity` 返回空， 导致空指针异常。
	
		解决方法: 
	
		重载 `Fragment` 中的 `onAttach(Context context)` 方法， 在该方法里调用 `getActivity()` 获取到 `Activity` 对象， 将该对象当做成员变量来使用。
	

	9. 通过 `Arrays.asList()` 获取的 `ArrayList` 不是我们常用的 ArrayList

		`asList()` 方法获取的是 `list` 对象，虽然 `class` 名是 `ArrayList`, 但却是 `Arrays`  的内部类，并没有实现 `add`, `remove` 等接口，所以如果使用 `add`, `remove`, 等方法，会 `crash`.
		
		解决方法： 使用 new ArrayList(Arrays.asList(arrays)) 获取 list， 就可以了.
		
	10. 自定义 `RecyclerView`, `ListView` 的 item 时，一定要注意 `ViewHolder` 的复用问题


	11. 在子线程后面进行其他操作时，如果涉及到 activity 对象，需要做一个 该 activity 是否销毁的判断：

		例如，如果在一个子线程中执行了一个耗时操作，然后结束后 回到主线程进行刷新UI,这时要判断一下，activity 或 fragment 是否 还活着。
	
	12. Crash : SQLiteException: Expression tree is too large (maximum depth 1000)

		这个 crash 的原因 是 在 sqlite 语句中 的 筛选条件里面 包含了太多的内容项，超过了1000 个，就会 crash。
		
		通常会出现在 删除记录时，例如， 筛选条件 `whereCause.append(ID + "=" + list.get(i).id)`, 然后循环添加 要删除的对象，如果 list 内容太多，就会造成 whereCause 十分的庞大，当超过 1000 深度时，便会 发生 这个 crash 。
		
		解决方案，
		
		1. 手动对 whereCause.append 进行限制，如果超过 1000 , 则执行 sqlite 删除语句，然后接着 另外一个 whereCause 去 添加条件, 再次去执行 删除语句。
	
		2. 如果条件可以替换为 IN 处理 

			```
			whereCause = "Table.column._ID IN (ids[1], ids[2], ids[3], ...);
			
			whereCause = "Table.column._ID = ids[1] OR Table.column._ID = ids[2] OR Table.column._ID = ids[3] ...";
			
			上面两者是等价的， 但是 第一种不会造成 上述 exception， in 只代表一条语句，但是 or 却有多个 or 出现
			```
	13. ImageView.setAlpha(int) 与 ImageView.setAlpha(float) 的区别

		这是一个文档里，很容易踩进去的坑。
		
		setAlpha(int) 是对 image 进行 alpha 进行变化， 范围是 0 ~ 255;
		
		setAlpha(float)  是对 view  进行 alpha 进行变化，范围是 0f ~ 1f;
		
		两个方法 做 透明度变化的对象不同，要千万注意，注意！！！， 如果混用，就会出现问题的。
		
		例如，如果是想利用 float 进行设置，刚开始设置了 setAlpha(0), 后面都是 setAlpha(float), 则会出现 这个 view 永远展示不出来的情况, 刚开始设置 setAlpha(0f) 则是正确的。
		
		注意：官方已经抛弃了  setAlpha(float) 这个方法，推荐使用 setImageAlpha(int) 这个方法. 
	
**状态列表**

在drawable 中的 xml 里面有很多种状态，例如：`android:state_pressed`、`android:state_focused`、`android:state_selected`等等

**需要注意的是:** android 将应用状态列表中第一个与对象当前状态匹配的项目，因此，如果列表中的第一个项目不含上述任何状态列表，则每次都会应用他，这就是默认值始终放在`xml`文件的最后的原因。例如下面：

```
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_pressed="true"
          android:drawable="@drawable/button_pressed" /> <!-- pressed -->
    <item android:state_focused="true"
          android:drawable="@drawable/button_focused" /> <!-- focused -->
    <item android:state_hovered="true"
          android:drawable="@drawable/button_focused" /> <!-- hovered -->
    <item android:drawable="@drawable/button_normal" /> <!-- default -->
</selector>
```

将此xml文件将状态列可绘制对象应用到按钮：

```
<Button
    android:layout_height="wrap_content"
    android:layout_width="wrap_content"
    android:background="@drawable/button" />
    
```

> 已上就是为了防止状态出错，所以把默认的放在最后一个位置。



### 接口的封装问题

写某一个接口是为了实现方法的回调等功能， 有时候定义了一个接口，里面有很多方法，把该接口作为方法的参数，去实现回调回来处理问题， 
 


**对动画的总结**

> 见另外一篇笔记

**对`WindowManager`总结**


**对`PercentLayout`的总结**