
# JVM (Java Virtual Machine) java 虚拟机
<!--more-->

JVM 的基本结构

![jvm 的基本结构](https://img-blog.csdn.net/20150315165508885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG9ueXRmamluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


### 类加载器 android 什么时候加载 class

这部分已经完成！！！ 我的老哥




### 内存区域部分


### 常见的垃圾回收算法



## 第二章 java 内存区域与内存溢出

java 虚拟机运行时数据区， 即内存区 主要有 五部分： 方法区， 虚拟机栈， 本地方法栈， 堆， 程序计数器。


同时它也可以分为两部分：

- 线程共享的部分：

	Java 堆， 方法区
	
- 线程私有的部分：

	虚拟机栈， 本地方法栈，程序计数器。
	
	> 为什么线程能私有？？？ 因为 在程序中，每个线程都会有自己的一份工作内存，私有的数据区即表示它们的内存区域是 线程的工作内存分配给它的。
	

一张图表示一下：

![](http://www.wanandroid.com/blogimgs/4f4f0aed-8faa-4039-a93a-920b9fa46e45.png)

下面分开介绍下：

### Java 堆

这是 jvm 管理的内存中，最大的一块了，Java 堆占据了很大一部分内存区域。此内存区域的**唯一目的**就是存放对象实例，几乎所有的对象实例都在这里分配内存。（这是书中的原话）

它的特点如下：


1. 因为这是一个比较大的区域块，我们说的 垃圾收集（GC），往往就是在此处去回收垃圾，把一些不用的对象内存给释放掉。

2. 现在商用的虚拟机（HotSpot） 总是会把 **Java 堆** 分为两部分，一部分为 **新生代**，一部分为**老年代**

	- **新生代：**

		1. 所有刚创建的对象总会先被放入在新生代里（然后它可能经过几次 GC 后， 还没死，就打怪升级了，进入了老年代里面）；
		
		2. 新生代里面会分为三部分：`eden`, `survivors0`, `survivors1`, 大致比例是：8 : 1 : 1;

			我的理解：其实就是在里面设置了几个关卡，想进入老年代里面，就得先从 `eden`--> `s0` 或 `s1` 里；
			
			刚创建的对象都会先放在第一个关卡 eden 里面，只有经历过一次或者多次 GC 还没死的对象，才有资格可以进入到 `s0` , `s1` 内，（也就是说，在s0, s1 区域的对象 都至少经历过一次 GC 并幸存下来）。
			
			在 `s0` , `s1` 内的幸存的“幸运儿”，在经过一段时间，仍然存活着，就有了资格进入老年代，进入到老年代里。
			
			> 注： 可能会有疑问，那 s0,和 s1 有什么区别呢？为啥要两个这个区域，把它们合并成一个，不做区分就可以完成以上工作了啊！！！，但是呢，具体的 GC 方法，我们这里还没说，在具体执行 GC 时 才可以发现 s0 和 s1 之间不一样的地方。在后面的垃圾收集在细说吧。		
			
	- **老年代：**

		1. 老年代里存放的都是一些生命周期较长的对象，他们往往都是我们在用的对象，所以在 GC 的时候不会去回收这些对象（因为它们本身还在被使用，不应该回收， 像 application 等）；
		
		2. 老年代，在实际的内存区域中，要比新生代大很多，大概比例为 2 ：1；
		3. 当老年代满时会触发 full GC， 
	
	
<!--	- **永久代**

		永久代主要用于存放静态文件，像 静态 Java 类、静态方法等。这些是在编译期间就被加载的，他们存放的位置就是 永久代. 永久代里面的东西与 GC 没有太大关系.-->


3. Java 堆 可以处于物理上的不连续的内存空间上，在逻辑上连续就好。

4. 如果在堆中没有内存完成实例分配，并且堆也无法再扩展，将会抛出`OutOfMemoryError`异常


### 方法区

方法区也是线程共享的，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。有一些说法是，把方法区和永久代关联起来，其实不是同一个概念，有些虚拟机用永久代来实现方法区，便于用永久代GC 来管理方法区。

它有一部分是 运行时常量池，用于存放在编译期间生成的各种字面量和符号引用。

那么什么是 `字面量` `符号引用` 呢？

- 字面量

	它比较接近 Java 语言层次的常量概念，如文本字符串，被声明为 final 的常量值等

- 符号常量

	符号常量则属于编译原理方便的概念，包括三类常量： 类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
	
	
#### 方法区 和 Java 堆的区别

有些说法为了区别 方法区和 Java堆，把 方法区归类为 非堆（ `Non-Heap` ）.

一般来说，**Java 堆 是 Java 代码可及的内存，是留给开发人员使用的； 而非堆， 是 JVM 留给自己的。** 所以方法区、 jvm 内部处理或优化所需的内存（如 JIT 编译后的代码缓存），每个类结构（如运行时的常量池、字段和方法数据）以及方法和构造方法的代码都在 非堆内存中。


#### 那么 方法区是如何回收的呢？方法区的回收


### **程序计数器**

当程序中有多个线程时， 可能线程之间就要进行抢夺 CPU 资源，在某一个时刻，cpu 只会执行一条线程中的指令，至于应该执行在这个线程的哪一个部分？这个就需要程序计数器来确保了。也就是说，在多线程情况下， 每个线程里面的程序记数器记录了 它应该执行的字节码指令的地址
， 所以，程序计数器，也应该是每个线程私有的。

其实它只有一小部分内存空间，供线程私有。





1. 线程共享区：

	* 方法区： java
	* 堆Heap
2. 线程隔离的数据区(线程私有)：

	* 虚拟机栈(VM Stack)
	* 本地方法栈(Native Method Stack)
	* 程序计数器(Program Counter Register)

**程序计数器**
是一块较小的内存空间， 线程私有。
> 当前线程所执行的字节码的行号指示器。
> 此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；
如果执行的是Native方法，这个计数器则为空。

**java 虚拟机栈**
也是线程私有的，它的生命周期和线程同步，描述的是Java方法执行的内存模型：
每个方法在执行的同时都会创建一个栈帧(`Stack Frame`)用于存储`局部变量表`、操作数栈、
动态链接、方法出口等信息。
> 每一个方法从调用直至执行难个完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
> 局部变量表：存放了编译期间可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个句柄或其他与此对象相关的位置）和
> `returnAddress`类型

在java虚拟机规范中：对这个区域规定了两种异常状况：
1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常；
2. 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出`OutOfMemoryError`异常

**本地方法栈**
native method stack 与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈
为虚拟机执行java方法(也就是字节码)服务， 而本地方法栈则为虚拟机所使用的Native方法服务。

> 也会抛出StackOverflow 和 OutOfMemoryError 异常

**Java 堆**
线程共享， java堆(Java Heap)是java 虚拟机所管理的内存中最大的一块。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
> java 堆是垃圾收集器的主要区域，GC(Garbage Collected Heap)堆.
> 收集器采用分代收集算法，所有java堆还分为：新生代和老生代
> 如果在堆中没有内存完成实例分配，并且堆也无法再扩展，将会抛出`OutOfMemoryError`异常

**方法区**
方法区(Method Area) 与java堆一样，是线程共享的内存区域。
用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
有一个别名叫做Non-Heap（非堆），目的是与java堆区分开。
在HotSpot虚拟机上被称为(永生代)，其实不等价

**运行时常量池**

> waiting



## 第三章:
#### 3.6.4 动态对象年龄判定
#### 3.6.5 空间分配担保

> 主要内容：介绍了垃圾收集算法， 垃圾收集器特点以及运作原理，
> 通过代码实例验证了，java虚拟机中自动内存分配及回收的主要规则

## 第四章： 虚拟机性能监控与故障处理工具
java 与C++ 之间有一个有内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。

### 4.1 概述：
实践去了解虚拟机内存管理的世界
### 4.2 JDK的命令行工具
JDK的bin目录下，有很多命令
#### 4.2.1 jps: 虚拟机进程状况工具
jps: (JVM Process Status Tool),可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class, main() 函数所在的类)名称以及这些进程的本地虚拟机唯一的ID(Local Virtual Machine Identifier, LVMID).

	//jps 命令格式
    jps [ options ] [ hostid ]
    // jps 执行样例
    D:\Develop\Java\jdk1.6.0_21\bin> jps -1
    2388 D:\Develop\glassfish\bin\..\modules\admin-cli.jar
    2764 com.sun.enterprise.glassfish.bootstrap.ASMain
    3788 sun.tools.jps.Jps

jps 可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。 jps 的其他常用选项如下：

1. -q : 只输出LVMID， 省略主类的名称
2. -m : 输出虚拟机进程启动时传递给主类main()函数的参数
3. -l : 输出主类的全名，如果进程执行的是Jar包， 输出Jar包， 输出Jar路径
4. -v : 输出虚拟机进程启动时JVM参数

#### 4.2.2 jstat: 虚拟机统计信息监视工具
jstat (JVM Statics Monitoring Tool) 用于监视虚拟机各种运行状态信息的命令行工具。

jstat 命令格式为：

	jstat [ option vmid [interval[s|ms] [count]] ]


### 12.4  java 与线程

线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独自调度。（线程是CPU调度的基本单位）。

实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级混合实现。

1. 使用内核线程实现

内核线程

## 第三章 垃圾收集器与内存分配策略
在堆里面存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是确定哪些对象还存活着，哪些已经死去。
**引用计数法**
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；所以，计数器为0的对象就是不可能再被使用的。
但它很难解决对象之间的相互循环引用问题，所以主流的java虚拟机并没有采用引用计数方法来管理内存。
**可达性分析算法**
在java语言中，可作为GCRoots 的对象包括下面几种：
1. 虚拟机栈中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(java Native Interface)（即一般说的native 方法）引用的对象。

#### 再谈引用
判断对象是否存活都与“引用”有关。
将引用分为强引用、软引用、弱引用、虚引用：
1. 强引用，就是普通的引用
	只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
2. 软引用是用来描述一些还有但并非必须的对象。
	对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还是没有足够的内存，才会抛出内存溢出异常。利用`SoftReference`类来实现软引用
3. 弱引用
	被弱引用关联的对象只能生存到下一次垃圾收集之前。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。`WeakReference`
4. 虚引用
	一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集回收时收到一个系统通知。

#### 回收方法区
其实方法区是有垃圾回收的，主要回收两部分内容： 废弃常量和无用的类。
废弃常量
无用的类：条件
1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
2. 加载该类的ClassLoader 已经被回收
3. 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法
##### 标记-清除算法
首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足：效率问题，二是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致无法找到一块连续的内存，而不得不提前触发一次垃圾收集动作。
##### 复制算法
将可用内存划分为等大的两块，每次只使用一块，但也存在很多问题
##### 标记-整理算法
标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
##### 分代收集算法
一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用合适的收集算法。在新生代中，每次垃圾收集都会有大批对象死去，只有少量存活，那就选用复制算法；而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须用`标记-清理`或者`标记-整理`算法回收。

### HotSpot算法实现
**枚举根节点**
java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用，
在HotMap的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。

**安全点**
在OopMap的协助下，HotSpot 可以快速且准确的完成GC Roots 枚举，问题是：可能导致引用关系变化，会需要很多OopMap指令，需要大量的额外空间，这样GC的空间成本会变得很高。
但事实上，HotSpot并没有为每条指令都生成OopMap,只是在特定的位置记录了这些信息，称为`安全点(Safepoint)` 程序执行时并非在所有地方都能停顿下开开始GC，只有在到达安全点时才能暂停。
**安全区域**
程序“不执行”的时候？就是指没有分配CPU时间，典型的例子就是线程处于sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，需要安全区域(Safe Region)来解决。

### 垃圾收集器
**Serial 收集器**
> 只会使用一个CPU，一条收集线程
> 在进行垃圾收集时必须暂停其他所有的工作线程。

**PalNew 收集器**


参考链接：

1. 深入理解 java 虚拟机 书本

2. [java 内存模型概述](http://www.wanandroid.com/blog/show/2152)

3. [图解Java 垃圾回收机制](https://blog.csdn.net/justloveyou_/article/details/71216049)